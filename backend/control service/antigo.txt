from fastapi import FastAPI, Request
from sqlalchemy import create_engine, Column, Float, Integer, MetaData, Table
from sqlalchemy.sql import select
from databases import Database
import requests
import logging


# configuração do log
logging.basicConfig(
    filename=r'C:\Users\gabri\OneDrive\Área de Trabalho\frank\projeto final\backend\server.log',
    level=logging.INFO,
    format='CONTROL %(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s'
)


# configuração da base de dados SQLite
DATABASE_URL = "sqlite:///./variables.db"
engine = create_engine(DATABASE_URL)
metadata = MetaData()
database = Database(DATABASE_URL)
metadata.create_all(engine)


# tabela da temperatura minima registrada pelo sensor para ativar o atuador
condition_table = Table(
   "condition", metadata,
   Column("id", Integer, primary_key=True),
   Column("value", Float)
)


# tabela  do angulo ao qual a hélice do atuador rotaciona
angle_table = Table(
   "angle", metadata,
   Column("id", Integer, primary_key=True),
   Column("value", Integer)
)


# retorna ip 0.0.0.0 da api em nuvem http://SalMolhado.pythonanywhere.com/ip
def get_ip():
    response = requests.get(f"http://SalMolhado.pythonanywhere.com/ip")
    return response.json()['value']


# se registra no Service Finder
def register_service(service_name, service_port):
    payload = {
        'service_name': service_name,
        'service_address': get_ip() + service_port,
    }
    response = requests.post(f'http://127.0.0.1:8001/register', json=payload)
    if response.status_code == 200:
        print("Service registered successfully")
    else:
        print("Failed to register service", response.status_code)


# realiza o registro
register_service('control', ':8003')


# configuração do servidor
app = FastAPI()


# desconecta-se da base de dados
@app.on_event("shutdown")
async def shutdown():
    await database.disconnect()


# registra informações após receber e após responder uma requisição
@app.middleware("http")
async def log_requests(request: Request, call_next):
    logging.info(f"Incoming request: {request.method} {request.url}")
    response = await call_next(request)
    logging.info(f"Response: {response.status_code}")
    return response


# ao iniciar
@app.on_event("startup")
async def startup():
    await database.connect()

    # reseta a tabela condition
    for id_value in [1, 2]:
        query = condition_table.select().where(condition_table.c.id == id_value)
        result = await database.fetch_one(query)
        if result is None:
            query = condition_table.insert().values(id=id_value, value=40.0)
        else:
            query = condition_table.update().where(condition_table.c.id == id_value).values(value=40.0)
        await database.execute(query)

    # reseta a tabela angle
    for id_value in [1, 2]:
        query = angle_table.select().where(angle_table.c.id == id_value)
        result = await database.fetch_one(query)
        if result is None:
            query = angle_table.insert().values(id=id_value, value=180)
        else:
            query = angle_table.update().where(angle_table.c.id == id_value).values(value=180)
        await database.execute(query)


# atualiza temperatura minima registrada pelo sensor para ativar o atuador
@app.post("/condition/{new_value}", status_code=201)
async def update_condition(new_value: float):
    query = condition_table.update().values(value=new_value).where(condition_table.c.id == 2)
    await database.execute(query)
    return {"status": "updated", "new_value": new_value}


# atualiza angulo ao qual a hélice do atuador rotaciona
@app.post("/angle/{new_value}", status_code=201)
async def update_angle(new_value: int):
    query = angle_table.update().values(value=new_value).where(angle_table.c.id == 2)
    await database.execute(query)
    return {"status": "updated", "new_value": new_value}


# retorna temperatura minima registrada pelo sensor para ativar o atuador
@app.get("/condition")
async def get_condition():
    query = select([condition_table]).where(condition_table.c.id == 2)
    result = await database.fetch_one(query)
    return result["value"]


# retorna angulo ao qual a hélice do atuador rotaciona
@app.get("/angle")
async def get_angle():
    query = select([angle_table]).where(angle_table.c.id == 2)
    result = await database.fetch_one(query)
    return result["value"]
